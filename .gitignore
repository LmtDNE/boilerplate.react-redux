################################################################################

#gitignore - Specifies intentionally untracked files to ignore.

#Files already tracked by Git are not affected.
#Each line in a gitignore file specifies a pattern.

#Formatting Patterns:
# 1)  A line starting with # serves as a comment. Put a backslash ("\") in front of
#     the first hash for patterns that begin with a hash.
# 2)  Trailing spaces are ignored unless they are quoted with backslash ("\").
# 3)  An optional prefix "!" which negates the pattern; any matching file excluded
#     by a previous pattern will become included again. It is not possible to
#     re-include a file if a parent directory of that file is excluded
# 5)  If the pattern ends with a slash, it is removed for the purpose of the
#     following description, but it would only find a match with a directory.
#     In other words, foo/ will match a directory foo and paths underneath it,
#     but will not match a regular file or a symbolic link foo (this is consistent
#     with the way how pathspec works in general in Git).
# 6)  If the pattern does not contain a slash /, Git treats it as a shell glob
#     pattern and checks for a match against the pathname relative to the location
#     of the .gitignore file (relative to the toplevel of the work tree if not
#     from a .gitignore file).
# 7)  Otherwise, Git treats the pattern as a shell glob suitable for consumption
#     by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not
#     match a / in the pathname. For example, "Documentation/*.html"
#     matches "Documentation/git.html" but not "Documentation/ppc/ppc.html" or
#     "tools/perf/Documentation/perf.html".
# 8)  A leading slash matches the beginning of the pathname. For example, "/*.c"
#     matches "cat-file.c" but not "mozilla-sha1/sha1.c".
# 9)  A leading "**" followed by a slash means match in all directories.
#     For example, "**/foo" matches file or directory "foo" anywhere, the same as
#     pattern "foo". "**/foo/bar" matches file or directory "bar" anywhere that
#     is directly under directory "foo".
# 10) A trailing "/**" matches everything inside. For example, "abc/**" matches
#     all files inside directory "abc", relative to the location of the .gitignore
#     file, with infinite depth.
# 11) A slash followed by two consecutive asterisks then a slash matches zero or
#     more directories. For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.

#Git checks gitignore patterns from multiple sources, with the following order
#of precedence:
# 1)  Read from the command line for commands that support them
# 2)  Patterns read from a .gitignore file in the same directory as the path,
#     or in any parent directory, with patterns in the higher level files (up
#     to the toplevel of the work tree) being overridden by those in lower level
#     files down to the directory containing the file.
# 3)  Patterns read from $GIT_DIR/info/exclude
# 4)  Patterns read from the file specified by the configuration
#     variable core.excludesFile

#But where should I place my patterns???

#gitignore file - Patterns which should be version-controlled and distributed to other
#repositories via clone (i.e., files that all developers will want to ignore)
#should go into a .gitignore file.

#$GIT_DIR/info/exclude file - Patterns which are specific to a particular
#repository but which do not need to be shared with other related repositories
#(e.g., auxiliary files that live inside the repository but are specific to
#one user’s workflow) should go into the $GIT_DIR/info/exclude file.

#Patterns which a user wants Git to ignore in all situations (e.g., backup or
#temporary files generated by the user’s editor of choice) generally go into a
#file specified by core.excludesFile in the user’s ~/.gitconfig. Its default
#value is $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME is either not set or
#empty, $HOME/.config/git/ignore is used instead.

################################################################################

#node modules are self contained packages that normally don't get edited in an
#application, so there is no reason to track these files. A simple npm install
#will get the necessary modules on whatever computer needs them.

node_modules

#These are files created by running tests with npm-debug

npm-debug.log

#The desktop services store (for Mac OS systems, similar to desktop.ini in Windows)
#is a file that stores custom attributes of its containing folder
#Although primarily used by Finder, these files were envisioned as a more
#general-purpose store of metadata about the display options of folders, such
#as icon positions and view settings.

.DS_Store

#distribution, usually contains the compiled software. This does not need to be
#tracked for the boilerplate's purposes

dist

#Lets just not track any logs (does not interfere with git log according to octocat)
*.log*
